import ndarray from 'ndarray'
import interpolate from 'ndarray-linear-interpolate/interp.js';

import { WrfProjection } from '../utils/wrf_proj.js';

import { polygonCentroid } from 'd3-polygon';

function structureArray(nx, ny, Z) {
    // Interpolates a curve defined by a collection of points.
    // point_collection is an array of points defining the curve.
    const grid = ndarray(new Float64Array(nx * ny), [nx, ny]);
    for (let i = 0; i < nx; i++) {
        for (let j = 0; j < ny; j++) {
            grid.set(i, j, Z[j*nx + i]);
        }
    }
    return grid;
}


                for (const key in data.domains) {
                    let {name, vars, dt, dx, map_proj} = data.domains[key];
                    let dy = dx
                    this.domains[key] = {
                        name: name,
                        vars: vars,
                        dt: dt,
                        dx: dx,
                        dy: dy,
                        map_proj: map_proj,
                    };

                    const basicVariables = ['LAT', 'LON'];
                    for (const varName of basicVariables) {
                        this.domains[key][varName]= await getData(this.dates[0],key,varName);
                        // this.domains[key][varName] = {nt, ev, ny, nx, min, max, totalScale};
                    }
  
                    // Contruimos LAT LON a valor real
                    const nx = this.domains[key]['LAT'].nx;
                    const ny = this.domains[key]['LAT'].ny;
                    this.domains[key]['LATREAL'] = this.domains[key]['LAT'].valuesApi(0,0).map(
                        lat => 
                            this.domains[key]['LAT'].min + (
                                this.domains[key]['LAT'].max - 
                                this.domains[key]['LAT'].min
                            ) * lat / this.domains[key]['LON'].totalScale
                    );
                    this.domains[key]['LONREAL'] = this.domains[key]['LON'].valuesApi(0,0).map(
                        lon => 
                            this.domains[key]['LON'].min + (
                                this.domains[key]['LON'].max - 
                                this.domains[key]['LON'].min
                            ) * lon / this.domains[key]['LON'].totalScale
                    );

                    // Creamos bordes
                    const borderCoords = [];
                    for (let i = 0; i < nx; i++) {   //Inferior
                        let j = 0;
                        borderCoords.push([
                            this.domains[key].LONREAL[j*nx + i],
                            this.domains[key].LATREAL[j*nx + i], 
                        ]);
                    }
                    for (let j = 0; j < ny; j++) {  //Derecho
                        let i = nx - 1;
                        borderCoords.push([
                            this.domains[key].LONREAL[j*nx + i],
                            this.domains[key].LATREAL[j*nx + i], 
                        ]);
                    }
                    for (let i = 0; i < nx; i++) {  //Superior
                        let j = ny - 1;
                        borderCoords.push([
                            this.domains[key].LONREAL[j*nx  + nx - 1 - i],
                            this.domains[key].LATREAL[j*nx + nx - 1 - i], 
                        ]);
                    }
                    for (let j = 0; j < ny; j++) {  //Izquierdo
                        let i = 0;
                        borderCoords.push([
                            this.domains[key].LONREAL[(ny - 1 - j)*nx + i],
                            this.domains[key].LATREAL[(ny - 1 - j)*nx + i], 
                        ]);
                    }
                    this.domains[key].borderCoords = borderCoords;

                    // Creamos proyeccion
                    const ZLON = structureArray(
                        nx,
                        ny,
                        this.domains[key].LONREAL
                    );
                    const ZLAT = structureArray(
                        nx,
                        ny,
                        this.domains[key].LATREAL
                    );
                    this.domains[key].proj_ij_to_lonlat = (x, y) => {
                        // Si x e y superar nos extremos, cambiar por el extremo
                        if (x < 0) x = 0;
                        if (x > nx - 1) x = nx - 1;
                        if (y < 0) y = 0;
                        if (y > ny - 1) y = ny - 1;
                        return [interpolate(ZLON, x, y), interpolate(ZLAT, x, y)]
                    }

                    // Generamos proyeccion inversa apoyado con WrfProjection
                    const centroidLONLAT = polygonCentroid(borderCoords);
                    
                    const wrf_proj       = new WrfProjection({
                        map_proj:  map_proj,
                        ref_lat:   centroidLONLAT[1],
                        ref_lon:   centroidLONLAT[0],
                        truelat1:  centroidLONLAT[1],
                        truelat2:  centroidLONLAT[1],
                        stand_lon: centroidLONLAT[0],
                    });
                    const centroidIJ = wrf_proj.latlon_to_ij(
                        centroidLONLAT[1], centroidLONLAT[0]
                    );
                    this.domains[key].centroidLONLAT = centroidLONLAT;
                    this.domains[key].ref_lat = centroidLONLAT[1];
                    this.domains[key].ref_lon = centroidLONLAT[0];
                    this.domains[key].centroidIJ = centroidIJ;
                    this.domains[key].extent = [
                        centroidIJ[0] - (nx-1) * dx / 2,
                        centroidIJ[1] - (ny-1) * dy / 2,
                        centroidIJ[0] + (nx-1) * dx / 2,
                        centroidIJ[1] + (ny-1) * dy / 2
                    ];
                    this.domains[key].proj_lonlat_to_ij = (lon, lat) => {
                        let [_x, _y] = wrf_proj.latlon_to_ij(lat, lon);
                        // Trasladamos y deformamos (dx dy) segÃºn el vertice inferior de extentAux
                        let x = (_x - this.domains[key].extent[0]) / dx;
                        let y = (_y - this.domains[key].extent[1]) / dy;
                        return [x, y];
                    }
                    this.domains[key].IJcentroid = this.domains[key].proj_lonlat_to_ij(
                        this.domains[key].centroidLONLAT[0],
                        this.domains[key].centroidLONLAT[1]
                    );

                    // Consultamos si hay variables U10 y V10
                    if (this.domains[key].vars.includes('U10') && this.domains[key].vars.includes('V10')) {
                        this.domains[key]['LATVEL10'] = await getData(this.dates[0], key, 'LATVEL10');
                        this.domains[key]['LONVEL10'] = await getData(this.dates[0], key, 'LONVEL10');
                        this.domains[key]['U10']= await getData(this.dates[0],key,'U10');
                        this.domains[key]['V10']= await getData(this.dates[0],key,'V10');
                        
                        // Contruimos LAT10 LON10 a valor real
                        this.domains[key]['LATVEL10REAL'] = this.domains[key]['LATVEL10'].valuesApi(0,0).map(
                            lat =>
                                this.domains[key]['LATVEL10'].min + (
                                    this.domains[key]['LATVEL10'].max -
                                    this.domains[key]['LATVEL10'].min
                                ) * lat / this.domains[key]['LATVEL10'].totalScale
                        );
                        this.domains[key]['LONVEL10REAL'] = this.domains[key]['LONVEL10'].valuesApi(0,0).map(
                            lon =>
                                this.domains[key]['LONVEL10'].min + (
                                    this.domains[key]['LONVEL10'].max -
                                    this.domains[key]['LONVEL10'].min
                                ) * lon / this.domains[key]['LONVEL10'].totalScale
                        );

                        this.domains[key]['U10REAL'] = []
                        this.domains[key]['V10REAL'] = []
                        
                        for (let t = 0; t < this.domains[key]['U10'].nt; t++) {
                            this.domains[key]['U10REAL'][t] = this.domains[key]['U10'].valuesApi(t,0).map(
                                u => this.domains[key]['U10'].min + (
                                    this.domains[key]['U10'].max - 
                                    this.domains[key]['U10'].min
                                ) * u / this.domains[key]['U10'].totalScale
                            );
                            this.domains[key]['V10REAL'][t] = this.domains[key]['V10'].valuesApi(t,0).map(
                                v => this.domains[key]['V10'].min + (
                                    this.domains[key]['V10'].max - 
                                    this.domains[key]['V10'].min
                                ) * v / this.domains[key]['V10'].totalScale
                            );
                        }


                    }

                }